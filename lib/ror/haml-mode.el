


(defvar haml-directives '("%" "=" "~" "-" "#" "." "/"))
(defvar haml-directives-regexp (concat "^\\W*\\(" (regexp-opt haml-directives) "\\)"))

(defvar haml-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [tab] 'haml-indent-line)
    (define-key map [ctrl tab] 'haml-indent-line)
    map)
  "Keymap for `haml-mode'.")

(let ((map (make-sparse-keymap)))
    (define-key map [tab] 'haml-indent-line)
    (define-key map (kbd "C-<tab>") 'haml-indent-haml-block)
    (define-key map (kbd "C-\\") 'haml-complete)
    (setq haml-mode-map map))

(defvar haml-font-lock-keywords
  `((,haml-directives-regexp
     (1 font-lock-keyword-face)))
  "Keyword highlighting specification for `haml-mode'.")


;;; Indentation


(defvar haml-current-indent-level 0)
(defvar haml-current-indent-line nil)


(defun haml-indent-line ()
  "Indent current line of Sample code."
  (interactive) 
  (let ((savep (> (current-column) (current-indentation)))) 
    (let ((indent (haml-calculate-indentation)))
      (if savep
	  (save-excursion (indent-line-to indent))
	(indent-line-to indent)))
    ))

(defun haml-calculate-indentation ()
  "Return the column to which the current line should be indented."
  (let (new-indentp)
    (when (not (eql haml-current-indent-line (line-number-at-pos)))
     (setq haml-current-indent-line (line-number-at-pos))
     (setq new-indentp t))
    (if (and (>= haml-current-indent-level 2)
	     (not new-indentp))
	(setq haml-current-indent-level (- haml-current-indent-level 2))
      (save-excursion
	(progn (forward-line -1)
	       (setq haml-current-indent-level (+ (current-indentation) 2)))))))

(lexical-let ((cur-line 0) beg end)
  (defun haml-indent-haml-block ()
   (interactive) 
   (let ((current-indent (current-indentation))
	 (new-indent (haml-calculate-indentation)))
     (when (not (= cur-line (line-number-at-pos)))
       (setq cur-line (line-number-at-pos))
       ;; should use region so is immune to point being moved
       (setq beg (point-marker))
       (while (and (= (forward-line 1) 0) (> (current-indentation) current-indent)))
       (unless (eobp) (forward-line -1))
       (end-of-line)
       (setq end (point-marker)))
     (message "%S" (list beg end))
     (goto-char beg)
     (beginning-of-line)
     (indent-rigidly (point) end (- new-indent current-indent))
     (goto-char beg)
     )))



 ;;;###autoload
 (define-derived-mode haml-mode nil "HAML"
   "A major mode for editing Sample files."
;;   (set (make-local-variable 'comment-start) "# ")
;;   (set (make-local-variable 'comment-start-skip) "#+\\s-*")
   (set (make-local-variable 'font-lock-defaults)
	'(haml-font-lock-keywords))
   (set (make-local-variable 'indent-line-function) 'haml-indent-line)
   (use-local-map haml-mode-map)
   (setq indent-tabs-mode nil)
   (setq haml-mode-abbrev-table ruby-mode-abbrev-table)
;;    (set (make-local-variable 'imenu-generic-expression)
;;         sample-imenu-generic-expression)
;;    (set (make-local-variable 'outline-regexp) sample-outline-regexp)
   
   )

(defun haml-complete ()
    "Complete if point is at end of a word, otherwise indent line."
    (interactive)
    (unless (when (and (boundp 'snippet) snippet) (snippet-next-field))
      (expand-abbrev)))



;; (defmacro* def-haml-snips ((&rest abbrev-tables) &rest snips)
;;   "Generate snippets with menu documentaion in several ABBREV-TABLES.

;;   (def-snip (some-mode-abbrev-table other-mode-abbrev-table)
;;     (\"abbr\"   \"some snip $${foo}\" \"menu documentation\")
;;     (\"anabr\"   \"other snip $${bar}\" \"menu documentation\")
;; "
;;   `(progn
;;      ,@(loop for table in abbrev-tables
;;              collect
;;              `(snippet-with-abbrev-table ',table
;;                                          ,@(loop for (name template desc) in snips collect
;;                                                  `(,name . ,template)))
;;              append)))

;; (def-haml-snips (ruby-mode-abbrev-table)
;;   ("all" "all? { |$${e}| $. }" "all? { |e| ... }")
;;   ("am" "alias_method :$${new_name}, :$${old_name}" "alias_method ...")
;;   ("amc" "alias_method_chain :$${first_method}, :$${second_method}" "alias_method_chain ...")
;;   ("any" "any? { |$${e}| $. }" "any? { |e| ... }")
;;   ("array" "Array.new($${10}) { |$${i}|$. }" "Array.new(10) { |i| ... }")
;;   ("art" "assert_redirected_to :action => \"$${index}\"" "assert_redirected_to")
;;   ("as" "assert($${test}, \"$${message}\")" "assert(...)")
;;   ("ase" "assert_equal($${expected}, $${actual})" "assert_equal(...)")
;;   ("asid" "assert_in_delta($${expected_float}, $${actual_float}, $${20})" "assert_in_delta(...)")
;;   ("asio" "assert_instance_of($${ExpectedClass}, $${actual_instance})" "assert_instance_of(...)")
;;   ("asko" "assert_kind_of($${ExpectedKind}, $${actual_instance})" "assert_kind_of(...)")
;;   ("asm" "assert_match(/$${expected_pattern}/, $${actual_string})" "assert_match(...)")
;;   ("asn" "assert_nil($${instance})" "assert_nil(...)")
;;   ("asne" "assert_not_equal($${unexpected}, $${actual})" "assert_not_equal(...)")
;;   ("asnm" "assert_no_match(/$${unexpected_pattern}/, $${actual_string})" "assert_no_match(...)")
;;   ("asnn" "assert_not_nil($${instance})" "assert_not_nil(...)")
;;   ("asnr" "assert_nothing_raised($${Exception}) { $. }" "assert_nothing_raised(...) { ... }")
;;   ("asns" "assert_not_same($${unexpected}, $${actual})" "assert_not_same(...)")
;;   ("asnt" "assert_nothing_thrown { $. }" "assert_nothing_thrown { ... }")
;;   ("aso" "assert_operator($${left}, :$${operator}, $${right})" "assert_operator(...)")
;;   ("asr" "assert_raise($${Exception}) { $. }" "assert_raise(...) { ... }")
;;   ("asre" "assert_response :$${success}" "assert_response")
;;   ("asrt" "assert_respond_to($${object}, :$${method})" "assert_respond_to(...)")
;;   ("ass" "assert_same($${expected}, $${actual})" "assert_same(...)")
;;   ("ass" "assert_send([$${object}, :$${message}, $${args}])" "assert_send(...)")
;;   ("ast" "assert_throws(:$${expected}) { $. }" "assert_throws(...) { ... }")
;;   ("b" "=begin rdoc\n$>$.\n=end" "New Block")
;;   ("begin" "begin\n$>$${paste}\nrescue $${Exception} => $${e}\n$>$.\n$>end\n" "begin ... rescue ... end")
;;   ("bm" "TESTS = $${10_000}\nBenchmark.bmbm($${10}) do |results|\n  $.\n$>end" "Benchmark.bmbm(...) do ... end")
;;   ("bt" "belongs_to :$${model}" "belongs_to")
;;   ("case" "case $${object}\nwhen $${condition}\n$>$.\n$>end" "case ... end")
;;   ("cl" "classify { |$${e}| $. }" "classify { |e| ... }")
;;   ("cladl" "class $${ClassName} < DelegateClass($${ParentClass})\n$>def initialize$${1}\n$>$>super($${del_obj})\n$>$>\n$>$>$.\n$>end\n$>\n$>\n$>end" "class ... < DelegateClass ... initialize ... end")
;;   ("clapr" "class $${ClassName} < $${ParentClass}\n$>def initialize$${1}\n$>$>$.\n$>end\n$>\n$>\n$>end" "class ... < ParentClass ... initialize ... end")
;;   ("clast" "class $${ClassName} < Struct.new(:$${attr_names})\n$>def initialize(*args)\n$>$>super\n$>$>\n$>$>$.\n$>end\n$>\n$>\n$>end" "class ... < Struct ... initialize ... end")
;;   ("class" "class $${ClassName}\n$>$.\n$>end" "class ... end")
;;   ("classi" "class $${ClassName}\n$>def initialize$${1}\n$>$>$.\n$>end\n$>\n$>\n$>end" "class ... initialize ... end")
;;   ("clasf" "class << $${self}\n$>$.\n$>end" "class << self ... end")
;;   ("clabl" "class $${BlankSlate}\n$>instance_methods.each { |meth| undef_method(meth) unless meth =~ /\\A__/ }\n$>\n$>def initialize$${var}\n$>$>@$${delegate} = $${delegate_object}\n$>$>\n$>$>$.\n$>end\n$>\n$>def method_missing(meth, *args, &block)\n$>$>@$${delegate}.send(meth, *args, &block)\n$>end\n$>\n$>\n$>end" "class BlankSlate ... initialize ... end")
;;   ("clafn" "split(\"::\").inject(Object) { |par, const| par.const_get(const) }" "class_from_name()")
;;   ("col" "collect { |$${e}| $. }" "collect { |e| ... }")
;;   ("collect" "collect { |$${element}| $${element}.$. }" "collect element")
;;   ("comp" "include Comparable\n\ndef <=>(other)\n$>$.\n$>end" "include Comparable ...")
;;   ("dee" "Marshal.load(Marshal.dump($${obj_to_copy}))" "deep_copy(...)")
;;   ("defd" "def_delegator :$${del_obj}, :$${del_meth}, :$${new_name}" "def_delegator ...")
;;   ("defds" "def_delegators :$${del_obj}, :$${del_methods}" "def_delegators ...")
;;   ("defs" "def self.$${class_method_name}\n$>$.\n$>end" "def self ... end")
;;   ("deft" "def test_$${case_name}\n$>$.\n$>end" "def test_ ... end")
;;   ("deli" "delete_if { |$${e}| $. }" "delete_if { |e| ... }")
;;   ("det" "detect { |$${e}| $. }" "detect { |e| ... }")
;;   ("dir" "Dir.glob($${glob}) { |$${file}| $. }" "Dir.glob(\"...\") { |file| ... }")
;;   ("do" "do\n$>$.\n$>end" "do ... end")
;;   ("doo" "do |$${object}|\n$>$.\n$>end" "Insert do |object| ... end")
;;   ("dow" "downto($${0}) { |$${n}|$. }" "downto(0) { |n| ... }")
;;   ("ea" "each { |$${e}| $. }" "each { |e| ... }")
;;   ("eab" "each_byte { |$${byte}| $. }" "each_byte { |byte| ... }")
;;   ("eac" "each_char { |$${chr}| $. }" "each_char { |chr| ... }")
;;   ("eac" "each_cons($${2}) { |$${group}| $. }" "each_cons(...) { |group| ... }")
;;   ("each" "each { |$${element}| $${element}.$. }" "each element")
;;   ("each_with_index" "each_with_index { |$${element}, $${idx}| $${element}.$. }" "each_with_index")
;;   ("eai" "each_index { |$${i}| $. }" "each_index { |i| ... }")
;;   ("eak" "each_key { |$${key}| $. }" "each_key { |key| ... }")
;;   ("eal" "each_line$${1} { |$${line}| $. }" "each_line { |line| ... }")
;;   ("eap" "each_pair { |$${name}, $${val}| $. }" "each_pair { |name, val| ... }")
;;   ("eas" "each_slice($${2}) { |$${group}| $. }" "each_slice(...) { |group| ... }")
;;   ("eav" "each_value { |$${val}| $. }" "each_value { |val| ... }")
;;   ("eawi" "each_with_index { |$${e}, $${i}| $. }" "each_with_index { |e, i| ... }")
;;   ("elsif" "elsif $${condition}\n$>$." "elsif ...")
;;   ("enum" "include Enumerable\n\ndef each(&block)\n$>$.\n$>end" "include Enumerable ...")
;;   ("fet" "fetch($${name}) { |$${key}|$. }" "fetch(name) { |key| ... }")
;;   ("fil" "fill($${range}) { |$${i}|$. }" "fill(range) { |i| ... }")
;;   ("file" "File.foreach($${file}) { |$${line}| $. }" "File.foreach (\"...\") { |line| ... }")
;;   ("fin" "find { |$${e}| $. }" "find { |e| ... }")
;;   ("fina" "find_all { |$${e}| $. }" "find_all { |e| ... }")
;;   ("fl" "flunk(\"$${message}\")" "flunk(...)")
;;   ("flao" "inject(Array.new) { |$${arr}, $${a}| $${arr}.push(*$${a}) }" "flatten_once()")
;;   ("flash" "flash[:$${notice}] = \"$${Successfully}\"$." "flash[...]")
;;   ("forin" "for $${element} in $${collection}\n$>$${element}.$.\n$>end" "for ... in ... end")
;;   ("forw" "extend Forwardable" "extend Forwardable")
;;   ("gre" "grep($${pattern}) { |$${match}| $. }" "grep(/pattern/) { |match| ... }")
;;   ("gsu" "gsub(/$${pattern}/) { |$${match}|$. }" "gsub(/.../) { |match| ... }")
;;   ("habtm" "has_and_belongs_to_many :$${object}" "has_and_belongs_to_many")
;;   ("hash" "Hash.new { |$${hash}, $${key}| $${hash}[$${key}] = $. }" "Hash.new { |hash, key| hash[key] = ... }")
;;   ("hm" "has_many :$${objects}" "has_many")
;;   ("ho" "has_one :$${object}" "has_one")
;;   ("if" "if $${condition}\n$>$.\n$>end" "if ... end")
;;   ("ife" "if $${condition}\n$>$${2}\nelse\n$>$${3}\n$>end" "if ... else ... end")
;;   ("inj" "inject($${init}) { |$${mem}, $${var}| $. }" "inject(init) { |mem, var| ... }")
;;   ("inject" "inject($${object}) { |$${injection}, $${element}| $${4} }$." "inject object")
;;   ("lam" "lambda { |$${args}|$. }" "lambda { |args| ... }")
;;   ("logd" "logger.debug \"$${message}\"$." "logger.debug")
;;   ("loge" "logger.error \"$${message}\"$." "logger.error")
;;   ("logf" "logger.fatal \"$${message}\"$." "logger.fatal")
;;   ("logi" "logger.info \"$${message}\"$." "logger.info")
;;   ("logw" "logger.warn \"$${message}\"$." "logger.warn")
;;   ("map" "map { |$${e}| $. }" "map { |e| ... }")
;;   ("mapwi" "enum_with_index.map { |$${e}, $${i}| $. }" "map_with_index { |e, i| ... }")
;;   ("max" "max { |a, b| $. }" "max { |a, b| ... }")
;;   ("mtclm" "t.column :$${title}, :$${string}\n$>mtclm$." "create several columns")
;;   ("mac" "add_column :$${table}, :$${column}, :$${string}" "add column")
;;   ("mtcl" "t.column :$${title}, :$${string}$." "create column")
;;   ("mrmc" "remove_column :$${table}, :$${column}" "remove column")
;;   ("mrec" "rename_column :$${column}, :$${new_column}" "rename column")
;;   ("md" "File.open($${dump}, \"w\") { |$${file}| Marshal.dump($${obj}, $${file}) }" "Marshal.dump(..., file)")
;;   ("min" "min { |a, b| $. }" "min { |a, b| ... }")
;;   ("ml" "File.open($${dump}) { |$${file}| Marshal.load($${file}) }" "Marshal.load(obj)")
;;   ("mm" "def method_missing(meth, *args, &block)\n$>$.\n$>end" "def method_missing ... end")
;;   ("modf" "module $${ModuleName}\n$>module ClassMethods\n$>$>$.\n$>end\n$>\n$>extend ClassMethods\n$>\n$>def self.included(receiver)\n$>$>receiver.extend(ClassMethods)\n$>end\n$>\n$>\n$>end" "module ... ClassMethods ... end")
;;   ("mods" "module $${ModuleName}\n$>$.\n$>end" "module ... end")
;;   ("modu" "module $${ModuleName}\n$>module_function\n$>\n$>$.\n$>end" "module ... module_function ... end")
;;   ("mct" "create_table :$${table} do |t|\n    $.\n$>end" "create table")
;;   ("mdct" "drop_table :$${table}\ncreate_table :$${table}" "drop / create Table")
;;   ("mdt" "drop_table :$${table}\n$." "drop table")
;;   ("mrt" "rename_table :$${table}, :$${new_name}$." "rename table")
;;   ("ope" "open($${pipe}) { |$${io}| $. }" "open(\"path/or/url\", \"w\") { |io| ... }")
;;   ("par" "partition { |$${e}| $. }" "partition { |e| ... }")
;;   ("params" "params[:$${id}]" "params[...]")
;;   ("patfh" "File.join(File.dirname(__FILE__), *%w[$${here}])" "path_from_here( ... )")
;;   ("pn" "PStore.new($${file_name})" "PStore.new( ... )")
;;   ("r" "attr_reader :$${attr_names}" "attr_reader ...")
  
;;   ("ran" "sort_by { rand }" "randomize()")
;;   ("rb" "#!/usr/bin/env ruby -w\n\n" "#!/usr/local/bin/ruby -w")
;;   ("rcea" "render_component :action => \"$${index}\"" "render_component (action)")
;;   ("rcec" "render_component :controller => \"$${items}\"" "render_component (controller)")
;;   ("rceca" "render_component :controller => \"$${items}\", :action => \"$${index}\"" "render_component (controller, action)")
;;   ("rdb" "RAILS_DEFAULT_LOGGER.debug \"$${message}\"$." "RAILS_DEFAULT_LOGGER.debug")
;;   ("rea" "redirect_to :action => \"$${index}\"" "redirect_to (action)")
;;   ("reai" "redirect_to :action => \"$${show}\", :id => $${item}" "redirect_to (action, id)")
;;   ("rec" "redirect_to :controller => \"$${items}\"" "redirect_to (controller)")
;;   ("reca" "redirect_to :controller => \"$${items}\", :action => \"$${list}\"" "redirect_to (controller, action)")
;;   ("recai" "redirect_to :controller => \"$${items}\", :action => \"$${show}\", :id => $${item}" "redirect_to (controller, action, id)")

;;   ("ra" "render :action => \"$${action}\"" "render (action)")
;;   ("ral" "render :action => \"$${action}\", :layout => \"$${layoutname}\"" "render (action, layout)")
;;   ("rf" "render :file => \"$${filepath}\"" "render (file)")
;;   ("rfu" "render :file => \"$${filepath}\", :use_full_path => $${false}" "render (file, use_full_path)")
;;   ("ri" "render :inline => \"$${hello}\"" "render (inline)")
;;   ("ril" "render :inline => \"$${hello}\", :locals => { $${name} => \"$${value}\"$${4} }" "render (inline, locals)")
;;   ("rit" "render :inline => \"$${hello}\", :type => $${rxml}" "render (inline, type)")
;;   ("rl" "render :layout => \"$${layoutname}\"" "render (layout)")
;;   ("rn" "render :nothing => $${true}" "render (nothing)")
;;   ("rns" "render :nothing => $${true}, :status => $${401}" "render (nothing, status)")
;;   ("rp" "render :partial => \"$${item}\"" "render (partial)")
;;   ("rpc" "render :partial => \"$${item}\", :collection => $${items}" "render (partial, collection)")
;;   ("rpl" "render :partial => \"$${item}\", :locals => { :$${name} => \"$${value}\"$${4} }" "render (partial, locals)")
;;   ("rpo" "render :partial => \"$${item}\", :object => $${object}" "render (partial, object)")
;;   ("rps" "render :partial => \"$${item}\", :status => $${500}" "render (partial, status)")
;;   ("rt" "render :text => \"$${render}\"" "render (text)")
;;   ("rtl" "render :text => \"$${render}\", :layout => \"$${layoutname}\"" "render (text, layout)")
;;   ("rtlt" "render :text => \"$${render}\", :layout => $${true}" "render (text, layout => true)")
;;   ("rts" "render :text => \"$${render}\", :status => $${401}" "render (text, status)")
  
;;   ("sel" "select { |$${e}| $. }" "select { |e| ... }")
;;   ("select" "select { |$${element}| $${element}.$${2} }$." "select element")
;;   ("session" "session[:$${User}]" "session[...]")
;;   ("sin" "class << self; self end" "singleton_class()")
;;   ("sor" "sort { |a, b| $. }" "sort { |a, b| ... }")
;;   ("sorb" "sort_by { |$${e}| $. }" "sort_by { |e| ... }")
;;   ("ste" "step($${2}) { |$${n}|$. }" "step(2) { |e| ... }")
;;   ("sub" "sub(/$${pattern}/) { |$${match}|$. }" "sub(/.../) { |match| ... }")
;;   ("tc" "require \"test/unit\"\n\nrequire \"$${library_file_name}\"\n\nclass Test$${amp} < Test::Unit::TestCase\n$>def test_$${case_name}\n$>$>$.\n$>end\n$>end" "class ... < Test::Unit::TestCase ... end")
;;   ("tim" "times { |$${n}|$. }" "times { |n| ... }")
;;   ("tra" "transaction$${1} { $. }" "transaction( ... ) { ... }")
;;   ("ts" "require \"test/unit\"\n\nrequire \"tc_$${test_case_file}\"\nrequire \"tc_$${test_case_file}\"\n" "require \"tc_...\" ...")
;;   ("unless" "unless $${condition}\n$>$.\n$>end" "unless ... end")
;;   ("until" "until $${condition}\n$>$.\n$>end" "until ... end")
;;   ("upt" "upto($${0}) { |$${n}|$. }" "upto(1.0/0.0) { |n| ... }")
;;   ("va" "validates_associated :$${attribute}" "validates_associated")
;;   ("vc" "validates_confirmation_of :$${attribute}" "validates_confirmation_of")
;;   ("ve" "validates_exclusion_of :$${attribute}" "validates_exclusion_of")
;;   ("verred" "verify :only => [:$${1}], :session => :user, :params => :id, :redirect_to => {:action => '$${index}'}\n" "verify -- redirect")
;;   ("verren" "verify :only => [:$${1}], :method => :post, :render => {:status => 500, :text => \"use HTTP-POST\"}\n" "verify -- render")
;;   ("vl" "validates_length_of :$${attribute}, :within => $${20}" "validates_length_of")
;;   ("vp" "validates_presence_of :$${attribute}" "validates_presence_of")
;;   ("vpif" "validates_presence_of :$${attribute}, :if => proc { |obj| $${condition} }" "validates_presence_of if")
;;   ("vu" "validates_uniqueness_of :$${attribute}" "validates_uniqueness_of")
;;   ("vuif" "validates_uniqueness_of :$${attribute}, :if => proc { |obj| $${condition} }" "validates_uniqueness_of if")
;;   ("w" "attr_writer :$${attr_names}" "attr_writer ...")
;;   ("when" "when $${condition}\n$>$." "when ...")
;;   ("while" "while $${condition}\n$>$.\n$>end" "while ... end")
;;   ("y" " :yields: $${arguments}" ":yields:")
;;   ("yd" "File.open($${yaml}, \"w\") { |$${file}| YAML.dump($${obj}, $${file}) }" "YAML.dump(..., file)")
;;   ("yl" "File.open($${yaml}) { |$${file}| YAML.load($${file}) }" "YAML.load(file)")
;;   ("zip" "zip($${enums}) { |$${row}| $. }" "zip(enums) { |row| ... }"))

;; (my-defkeys haml-mode-map
;; 	    ((kbd "C-\\") 'haml-indent-haml-block))
	    
;; (defun foo ()
;;   (interactive)
;;   (message "%d" (forward-line)))


;; (provide 'sample)